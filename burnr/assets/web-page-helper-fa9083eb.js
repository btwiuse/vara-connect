var R="chainHead_unstable_follow",A="chainHead_unstable_unfollow",y="chainHead_unstable_followEvent",O="stop",m=new Set([O,"operationInaccessible","operationError"]),I=t=>({onSent(e){return e.method===R?{type:"subscribe",id:e.id,onRes:n=>n.id===e.id?{id:n.result}:null}:e.method===A?{type:"unsubscribe",id:Object.values(e.params)[0]}:null},onNotification(e){return e.method!==y?null:m.has(e.params.result.event)?{type:"end",id:e.params.subscription}:null},onAbort:e=>{t(JSON.stringify({jsonrpc:"2.0",method:y,params:{subscription:e,result:{event:O}}}))}}),P="transaction_unstable_submitAndWatch",M="transaction_unstable_unwatch",T="transaction_unstable_watchEvent",_="dropped",x=new Set([_,"finalized","error","invalid"]),k=t=>({onSent(e){return e.method===P?{type:"subscribe",id:e.id,onRes:n=>n.id===e.id?{id:n.result}:null}:e.method===M?{type:"unsubscribe",id:Object.values(e.params)[0]}:null},onNotification(e){return e.method!==T?null:x.has(e.params.result.event)?{type:"end",id:e.params.subscription}:null},onAbort:e=>{t(JSON.stringify({jsonrpc:"2.0",method:T,params:{subscription:e,result:{event:_}}}))}}),H=({onSent:t,onNotification:e,onAbort:n})=>{const s=new Map,f=new Set,u=()=>{s.clear(),f.clear()};return{onSent(r){const o=t(r);o&&(o.type==="subscribe"?s.set(o.id,o.onRes):f.delete(o.id))},onResponse(r){var l;const o=(l=s.get(r.id))==null?void 0:l(r);o&&(s.delete(r.id),f.add(o.id))},onNotifiaction(r){const o=e(r);o&&f.delete(o.id)},onDisconnect:u,onAbort(){const r=[...f];u(),r.forEach(n)}}},B=t=>{const e=[I,k].map(n=>H(n(t)));return{onSent(n){e.forEach(s=>{s.onSent(n)})},onResponse(n){e.forEach(s=>{s.onResponse(n)})},onNotifiaction(n){e.forEach(s=>{s.onNotifiaction(n)})},onDisconnect(){e.forEach(n=>n.onDisconnect())},onAbort(){e.forEach(n=>n.onAbort())}}},j=t=>e=>{let n,s=[];const f=new Set,u=B(e),r=d=>{let i;try{i=JSON.parse(d)}catch{console.error(`Unable to parse incoming message: ${d}`);return}i.id!==void 0?(f.delete(i.id),u.onResponse(i)):u.onNotifiaction(i),e(d)},o=d=>{if(!n)return;const i=JSON.parse(d);u.onSent(i),i.id&&f.add(i.id),n instanceof Promise?s.push(d):n.send(d)},l=()=>{s=[];const d=[...f];if(f.clear(),!n)throw null;const i=a();return u.onAbort(),d.forEach(p=>{e(JSON.stringify({jsonrpc:"2.0",error:{code:-32603,message:"Internal error"},id:p}))}),i},a=()=>{const d=i=>{let p=!1;const g=i(b=>{p||r(b)},()=>{p||(p=!0,l())});return s.forEach(b=>{g.send(b)}),s=[],n=g};return n=t().then(d,U(l)),n},c=()=>{if(!n)return;const d=i=>{u.onDisconnect(),f.clear(),n=null,i==null||i.disconnect()};n instanceof Promise?(n.then(d,d),n=null):d(n)};return a(),{send:o,disconnect:c}},U=t=>(...e)=>new Promise(n=>setTimeout(n,0)).then(()=>t(...e)),$="@polkadot-api/light-client-extension-helper",v=`${$}-context`,h={CONTENT_SCRIPT:`${v}-content-script`,BACKGROUND:`${v}-background`,EXTENSION_PAGE:`${v}-extension-page`,WEB_PAGE:`${v}-web-page`},D=()=>{const t=new BigUint64Array(2);return crypto.getRandomValues(t),(t[1]<<BigInt(64)|t[0]).toString(36)},J=({genesisHash:t,chainSpec:e,relayChainGenesisHash:n,postMessage:s,addOnMessageListener:f,addOnDisconnectListener:u})=>j(async()=>{const r=D();return await new Promise((o,l)=>{const a=f(c=>{if((c==null?void 0:c.chainId)===r){switch(c.type){case"chain-ready":{o();break}case"error":{l(new Error(c.errorMessage));break}default:l(new Error(`Unrecognized message ${JSON.stringify(c)}`));break}a()}});s(e?{origin:"substrate-connect-client",type:"add-chain",chainId:r,chainSpec:e,potentialRelayChainIds:n?[n]:[]}:{origin:"substrate-connect-client",type:"add-well-known-chain",chainId:r,chainName:t})}),(o,l)=>{const a=f(i=>{if(i.chainId===r)switch(i.type){case"rpc":{o(i.jsonRpcMessage);break}case"error":{console.error(i.errorMessage),d(),l();break}default:console.warn(`Unrecognized message ${JSON.stringify(i)}`);break}}),c=u==null?void 0:u(l),d=()=>{a(),c==null||c()};return{send(i){s({origin:"substrate-connect-client",type:"rpc",chainId:r,jsonRpcMessage:i})},disconnect(){d(),s({origin:"substrate-connect-client",type:"remove-chain",chainId:r})}}}}),G=t=>e=>!(!e||!t.includes(e==null?void 0:e.origin)||!(e!=null&&e.type)),C=t=>window.postMessage(t,window.origin),W=G([h.CONTENT_SCRIPT,h.BACKGROUND,"substrate-connect-extension"]),N=new Set,F=async t=>{const e=[];if(N.has(t))throw new Error(`channelId "${t}" already in use`);N.add(t);const n={};window.addEventListener("message",({data:r,source:o})=>{if(o!==window||!r)return;const{channelId:l,msg:a}=r;if(l===t&&W(a)){if(a.origin==="substrate-connect-extension")return w.forEach(c=>c(a));if(a.origin===h.CONTENT_SCRIPT){const c=n[a.id];if(!c)return console.warn("Unhandled response",a);a.type==="error"?c.reject(a.error):c.resolve(a),delete n[a.id];return}if(a.origin===h.BACKGROUND&&a.type==="onAddChains")return e.forEach(c=>c(Object.fromEntries(Object.entries(a.chains).map(([d,{genesisHash:i,name:p}])=>[d,E(t,{genesisHash:i,name:p})]))));console.warn("Unhandled message",a)}});const s=(r,o)=>{const l=new Promise((a,c)=>{n[o.id]={resolve:a,reject:c}});return C({channelId:r,msg:o}),l},f=(r=>()=>""+r++)(0);let{chains:u}=await s(t,{origin:h.WEB_PAGE,id:f(),type:"getChains"});return e.push(r=>u=r),{async getChain(r,o){const{chain:l}=await s(t,{origin:h.WEB_PAGE,id:f(),type:"getChain",chainSpec:r,relayChainGenesisHash:o});return E(t,u[l.genesisHash]?l:{...l,chainSpec:r,relayChainGenesisHash:o})},getChains(){return Object.entries(u).reduce((r,[o,l])=>(r[o]=E(t,l),r),{})},addChainsChangeListener(r){return e.push(r),()=>S(e,r)}}},w=[],E=(t,{name:e,genesisHash:n,chainSpec:s,relayChainGenesisHash:f})=>({name:e,genesisHash:n,connect:J({genesisHash:n,chainSpec:s,relayChainGenesisHash:f,postMessage(u){C({channelId:t,msg:u})},addOnMessageListener(u){return w.push(u),()=>S(w,u)}})}),S=(t,e)=>{t.splice(t.indexOf(e),1)};export{F as getLightClientProvider};
