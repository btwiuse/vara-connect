import{g as b}from"./index-ac4443d8.js";var N="@polkadot-api/light-client-extension-helper",w=`${N}-context`,l={CONTENT_SCRIPT:`${w}-content-script`,BACKGROUND:`${w}-background`,EXTENSION_PAGE:`${w}-extension-page`,WEB_PAGE:`${w}-web-page`},P=()=>{const e=new BigUint64Array(2);return crypto.getRandomValues(e),(e[1]<<BigInt(64)|e[0]).toString(36)},R=({genesisHash:e,chainSpec:n,relayChainGenesisHash:c,postMessage:d,addOnMessageListener:p,addOnDisconnectListener:s})=>b(async()=>{const r=P();return await new Promise((o,a)=>{const t=p(i=>{if((i==null?void 0:i.chainId)===r){switch(i.type){case"chain-ready":{o();break}case"error":{a(new Error(i.errorMessage));break}default:a(new Error(`Unrecognized message ${JSON.stringify(i)}`));break}t()}});d(n?{origin:"substrate-connect-client",type:"add-chain",chainId:r,chainSpec:n,potentialRelayChainIds:c?[c]:[]}:{origin:"substrate-connect-client",type:"add-well-known-chain",chainId:r,chainName:e})}),(o,a)=>{const t=p(u=>{if(u.chainId===r)switch(u.type){case"rpc":{o(u.jsonRpcMessage);break}case"error":{console.error(u.errorMessage),h(),a();break}default:console.warn(`Unrecognized message ${JSON.stringify(u)}`);break}}),i=s==null?void 0:s(a),h=()=>{t(),i==null||i()};return{send(u){d({origin:"substrate-connect-client",type:"rpc",chainId:r,jsonRpcMessage:u})},disconnect(){h(),d({origin:"substrate-connect-client",type:"remove-chain",chainId:r})}}}}),x=e=>n=>!(!n||!e.includes(n==null?void 0:n.origin)||!(n!=null&&n.type)),v=e=>window.postMessage(e,window.origin),T=x([l.CONTENT_SCRIPT,l.BACKGROUND,"substrate-connect-extension"]),C=new Set,I=async e=>{const n=[];if(C.has(e))throw new Error(`channelId "${e}" already in use`);C.add(e);const c={};window.addEventListener("message",({data:r,source:o})=>{if(o!==window||!r)return;const{channelId:a,msg:t}=r;if(a===e&&T(t)){if(t.origin==="substrate-connect-extension")return g.forEach(i=>i(t));if(t.origin===l.CONTENT_SCRIPT){const i=c[t.id];if(!i)return console.warn("Unhandled response",t);t.type==="error"?i.reject(t.error):i.resolve(t),delete c[t.id];return}if(t.origin===l.BACKGROUND&&t.type==="onAddChains")return n.forEach(i=>i(Object.fromEntries(Object.entries(t.chains).map(([h,{genesisHash:u,name:E}])=>[h,f(e,{genesisHash:u,name:E})]))));console.warn("Unhandled message",t)}});const d=(r,o)=>{const a=new Promise((t,i)=>{c[o.id]={resolve:t,reject:i}});return v({channelId:r,msg:o}),a},p=(r=>()=>""+r++)(0);let{chains:s}=await d(e,{origin:l.WEB_PAGE,id:p(),type:"getChains"});return n.push(r=>s=r),{async getChain(r,o){const{chain:a}=await d(e,{origin:l.WEB_PAGE,id:p(),type:"getChain",chainSpec:r,relayChainGenesisHash:o});return f(e,s[a.genesisHash]?a:{...a,chainSpec:r,relayChainGenesisHash:o})},getChains(){return Object.entries(s).reduce((r,[o,a])=>(r[o]=f(e,a),r),{})},addChainsChangeListener(r){return n.push(r),()=>y(n,r)}}},g=[],f=(e,{name:n,genesisHash:c,chainSpec:d,relayChainGenesisHash:p})=>({name:n,genesisHash:c,connect:R({genesisHash:c,chainSpec:d,relayChainGenesisHash:p,postMessage(s){v({channelId:e,msg:s})},addOnMessageListener(s){return g.push(s),()=>y(g,s)}})}),y=(e,n)=>{e.splice(e.indexOf(n),1)};export{I as getLightClientProvider};
