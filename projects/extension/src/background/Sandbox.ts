import { ToApplication } from "@substrate/connect-extension-protocol"
import {
  Client as SmoldotClient,
  Chain as SmoldotChain,
  CrashError,
} from "smoldot"
import { SandboxIF, ToOutside } from "./types"
import createAsyncFifoQueue from "./Stream"

export class Sandbox<SandboxId> {
  #smoldotClient: SmoldotClient
  #sandboxes: Map<SandboxId, SandboxIF> = new Map()
  #wellKnownChainSpecs: Map<string, string> = new Map()
  #hasCrashed: string | undefined

  constructor(
    wellKnownChainSpecs: Map<string, string>,
    smoldotClient: SmoldotClient,
  ) {
    this.#wellKnownChainSpecs = wellKnownChainSpecs
    this.#smoldotClient = smoldotClient

    console.log("Sandox.ts")
  }

  /**
   * Inserts a sandbox in the list of sandboxes held by this state machine.
   *
   * @throws Throws an exception if a sandbox with that identifier already exists.
   */
  addSandbox(sandboxId: SandboxId) {
    if (this.#sandboxes.has(sandboxId)) throw new Error("Duplicate sandboxId")

    const queue = createAsyncFifoQueue<ToApplication | ToOutside | null>()
    this.#sandboxes.set(sandboxId, {
      pushMessagesQueue: queue.push,
      pullMessagesQueue: queue.pull,
      chains: new Map(),
    })
  }

  /**
   * Removes a sandbox from the list of sandboxes.
   *
   * This performs some internal clean ups.
   *
   * Any `Promise` concerning this sandbox that was returned by
   * {ConnectionManager.nextSandboxMessage} will generate an error.
   *
   * @throws Throws an exception if the ̀`sandboxId` isn't valid.
   */
  deleteSandbox(sandboxId: SandboxId) {
    const sandbox = this.#sandboxes.get(sandboxId)!
    sandbox.chains.forEach((chain) => {
      if (chain.isReady) {
        try {
          chain.smoldotChain.remove()
        } catch (error) {}
      }

      // If the chain isn't ready yet, the function that asynchronously reacts to the chain
      // initialization being finished will remove it.
    })
    sandbox.pushMessagesQueue(null)
    this.#sandboxes.delete(sandboxId)
  }

  /**
   * Returns the next {@link ToApplication} message that is generated spontaneously or in
   * response to {@link ConnectionManager.sandboxMessage}.
   *
   * Alternatively, can also generate a {@link ToOutside}.
   *
   * If a message is generated by a sandbox before this function is called, the message is queued.
   *
   * @throws Throws an exception if the ̀`sandboxId` isn't valid.
   */
  async nextSandboxMessage(
    sandboxId: SandboxId,
  ): Promise<ToApplication | ToOutside> {
    const sandbox = this.#sandboxes.get(sandboxId)!
    const message = await sandbox.pullMessagesQueue()
    if (message === null) throw new Error("Sandbox has been destroyed")
    return message
  }
}
